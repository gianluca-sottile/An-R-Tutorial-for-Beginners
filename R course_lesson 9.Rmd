---
pagetitle: "Lesson 9"
title: "Functions in R Programming"
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  message = FALSE,
  warning = FALSE
)
```

# What is a function in R?

A function is a reusable piece of code. It helps you:
- avoid repetition,
- reduce complexity,
- make code easier to test and maintain.

A function can:
- take inputs (arguments),
- execute a body,
- return a value (explicitly with `return()` or implicitly as the last expression).

Basic syntax:

```{r, eval=FALSE}
my_fun <- function(arg1, arg2 = default_value, ...) {
  # body
}
```

# Built-in functions (examples)

R ships with many built-in functions. Arguments can be provided by position or by name, and many arguments have defaults.

## diff(): compute differences

`diff()` is often used in time series workflows to compute lag-1 differences.

```{r}
set.seed(123)

x <- rnorm(1000)
ts_data <- cumsum(x)

diff_ts <- diff(ts_data)

par(mfrow = c(1, 2))
plot(ts_data, type = "l", main = "Cumulative sum")
plot(diff_ts, type = "l", main = "First differences")
```

## length(): number of elements

`length()` returns:
- number of elements for vectors,
- number of columns for data frames/matrices.

```{r}
data("cars", package = "datasets")

dt <- cars
length(dt)        # number of columns
nrow(dt)          # number of rows (preferred for data frames)
length(dt$speed)  # length of a vector
```

# Math functions

```{r, echo=FALSE}
library(knitr)

dt_math <- data.frame(
  Function = c("abs(x)", "log(x, base = b)", "exp(x)", "sqrt(x)", "factorial(x)"),
  Description = c(
    "Absolute value",
    "Logarithm (natural log if base is omitted)",
    "Exponential",
    "Square root",
    "Factorial"
  )
)

k <- knitr::kable(dt_math)
if (requireNamespace("kableExtra", quietly = TRUE)) {
  k <- kableExtra::kable_styling(k, bootstrap_options = c("striped", "hover"))
}
k
```

```{r}
x_vector <- 1:5
abs(c(-2, 0, 3))
log(x_vector)
exp(x_vector)
sqrt(x_vector)
factorial(x_vector)
```

# Statistical functions

```{r, echo=FALSE}
library(knitr)

dt_stats <- data.frame(
  Function = c("mean(x)", "median(x)", "var(x)", "sd(x)", "scale(x)", "quantile(x)", "summary(x)"),
  Description = c(
    "Mean",
    "Median",
    "Variance",
    "Standard deviation",
    "Z-scores (standardization)",
    "Quantiles",
    "Min/1st Qu./Median/Mean/3rd Qu./Max"
  )
)

k <- knitr::kable(dt_stats)
if (requireNamespace("kableExtra", quietly = TRUE)) {
  k <- kableExtra::kable_styling(k, bootstrap_options = c("striped", "hover"))
}
k
```

```{r}
speed <- dt$speed

mean(speed)
median(speed)
var(speed)
sd(speed)
head(scale(speed), 5)
quantile(speed)
summary(speed)
```

# Writing your own functions

A user-defined function has:
- a name,
- arguments (with optional defaults),
- a body.

## One-argument function

```{r}
square <- function(n) {
  n^2
}

square(4)
square(1:5)
```

If you remove a function, check with `exists()`:

```{r}
rm(square)
exists("square")
```

## Argument matching (quick demo)

```{r}
times <- function(x, y) x * y

times(2, 4)          # positional
times(y = 4, x = 2)  # named (order does not matter)
```

# Environments and scoping (lexical scoping)

Functions look for variables in their own local environment first; if not found, they search in the environment where the function was created.

```{r}
y <- 10
f <- function(x) x + y

f(5)   # uses y from outside the function
y
```

Local variables shadow global ones:

```{r}
y <- 10
g <- function(x) {
  y <- 100
  x + y
}

g(5)
y
```

# When should you write a function?

If you copy/paste the same logic more than once or twice, it is usually worth writing a function.

## Example: normalize to [0, 1]

\[
\text{normalize}(x) = \frac{x - x_{\min}}{x_{\max} - x_{\min}}
\]

A robust implementation should handle missing values and constant vectors.

```{r}
normalize01 <- function(x, na.rm = TRUE) {
  rng <- range(x, na.rm = na.rm)
  denom <- rng[2] - rng[1]

  if (is.na(denom) || denom == 0) {
    return(rep(0, length(x)))
  }

  (x - rng) / denom
}
```

Apply it to multiple columns with modern syntax:

```{r}
library(tibble)
library(dplyr)

df_example <- tibble(
  c1 = rnorm(50, 5, 1.5),
  c2 = rnorm(50, 5, 1.5),
  c3 = rnorm(50, 5, 1.5)
)

df_example <- df_example |>
  mutate(across(starts_with("c"), normalize01, .names = "{.col}_norm"))

df_example |> select(ends_with("_norm")) |> head(5)
```

# Functions with conditions: train/test split

A more practical split function usually:
- takes a proportion,
- optionally takes a seed for reproducibility,
- returns both train and test sets.

```{r}
split_data <- function(df, prop = 0.8, seed = NULL) {
  stopifnot(is.data.frame(df))
  stopifnot(prop > 0 && prop < 1)

  if (!is.null(seed)) set.seed(seed)

  n <- nrow(df)
  n_train <- floor(prop * n)
  idx_train <- sample.int(n, size = n_train)

  list(
    train = df[idx_train, , drop = FALSE],
    test  = df[-idx_train, , drop = FALSE]
  )
}
```

Test it:

```{r}
data("airquality", package = "datasets")

spl <- split_data(airquality, prop = 0.8, seed = 123)
dim(spl$train)
dim(spl$test)
```
