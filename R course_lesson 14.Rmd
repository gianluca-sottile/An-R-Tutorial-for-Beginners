---
pagetitle: "Lesson 14"
title: "Import Data into R: Read CSV, Excel, SPSS, Stata, SAS Files"
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", message = FALSE, warning = FALSE)
```

# Read CSV

CSV (comma-separated values) is one of the most common data formats.

## Base R: read.csv()

```{r, eval=FALSE}
read.csv(file, header = TRUE, sep = ",")
```

Notes:
- Since R 4.0, strings are **not** converted to factors by default, but older code often included `stringsAsFactors = FALSE`; keeping it can be useful for portability.
- On Windows, paths in quotes need escaping (`\\`) or use forward slashes (`/`).

```{r}
PATH <- "raw_data/mtcars.csv"

# Keep stringsAsFactors explicitly for compatibility across R versions
df <- read.csv(PATH, header = TRUE, sep = ",", stringsAsFactors = FALSE)

ncol(df)
str(df)
```

## Tidyverse alternative: readr::read_csv()

```{r, eval=FALSE}
readr::read_csv(PATH)
```

# Read Excel

The `readxl` package reads both `.xls` and `.xlsx` files.

```{r}
library(readxl)
```

## readxl_example()

`readxl_example()` lists example spreadsheets shipped with the package.

```{r}
readxl_example()
readxl_example("datasets.xlsx")
```

## read_excel()

```{r, eval=FALSE}
read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, n_max = Inf, na = "")
```

Examples (sheet by name or index):

```{r}
example <- readxl_example("datasets.xlsx")

df1 <- read_excel(example)                 # default first sheet
sheets <- excel_sheets(example)            # list sheets
sheets

quakes_a <- read_excel(example, sheet = "quakes")
quakes_b <- read_excel(example, sheet = 3)

identical(quakes_a, quakes_b)
```

### Read only first rows

```{r}
iris_head <- read_excel(example, n_max = 5, col_names = TRUE)
iris_head
```

### Read a rectangular range (Excel notation)

```{r}
range_ab <- read_excel(example, range = "A1:B5", col_names = TRUE)
dim(range_ab)
```

### Read specific rows/columns (cell_rows / cell_cols)

`cell_rows()` and `cell_cols()` give fine control over the imported rectangle.

```{r}
rows_1_5 <- read_excel(example, range = cell_rows(1:5), col_names = TRUE)
dim(rows_1_5)

cols_ab <- read_excel(example, range = cell_cols("A:B"))
dim(cols_ab)
```

### Treat a value as missing (na argument)

```{r}
iris_na <- read_excel(example, na = "setosa")
sum(is.na(iris_na))
```

# Import SAS / Stata / SPSS

The `haven` package imports (and exports) common file formats from other statistical software, including SAS, Stata, and SPSS.

```{r}
library(haven)
```

## Read SAS

```{r}
PATH_sas <- "raw_data/binary.sas7bdat"
df_sas <- read_sas(PATH_sas)
head(df_sas)
```

## Read Stata

```{r}
PATH_stata <- "raw_data/binary.dta"
df_stata <- read_dta(PATH_stata)
head(df_stata)
```

## Read SPSS

```{r}
PATH_spss <- "raw_data/binary.sav"
df_spss <- read_sav(PATH_spss)
head(df_spss)
```

Tip: `haven::read_spss()` can also choose between SPSS formats based on file extension.

# Best practices

- Use the first row as column names (headers).
- Avoid spaces and special characters in column names; prefer `snake_case`.
- Use a consistent missing-value marker (e.g., blank cells or `NA`) and declare it via `na = ...` when importing.
- Keep raw data immutable; do cleaning in separate scripts.

# Summary

```{r, echo=FALSE}
library(knitr)

dt <- data.frame(
  Library = c("utils (base R)", "readxl", "haven", "haven", "haven"),
  Objective = c("Read CSV", "Read Excel", "Read SAS", "Read Stata", "Read SPSS"),
  Function = c("read.csv()", "read_excel()", "read_sas()", "read_dta()", "read_sav()"),
  Key_args = c(
    "file, header=TRUE, sep=','",
    "path, sheet, range, col_names, n_max, na",
    "data_file",
    "file",
    "file"
  )
)

k <- kable(dt)

if (requireNamespace("kableExtra", quietly = TRUE)) {
  k <- kableExtra::kable_styling(k, bootstrap_options = c("striped", "hover"))
}

k
```
