---
pagetitle: "Lesson 5"
title: "Data Frames: Create, Append, Select, Subset"
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  message = FALSE,
  warning = FALSE
)
```

# What is a data frame?

A **data frame** is a table-like object where:
- each column is a vector,
- all columns have the same length,
- different columns can have different types (numeric, character, logical, factor, ...).

A matrix can only store one type (all numeric, all character, etc.), while a data frame can mix types.

# Create a data frame

You can create a data frame with `data.frame()` or (recommended for modern workflows) `tibble::tibble()`.

## Base R: data.frame()

```{r, eval=FALSE}
data.frame(..., stringsAsFactors = FALSE)
```

Note: In R ≥ 4.0 the default is effectively `stringsAsFactors = FALSE`, but it can be set explicitly for compatibility or teaching.

## Example

```{r}
df <- data.frame(
  ID    = c(10, 20, 30, 40),
  item  = c("book", "pen", "textbook", "pencil_case"),
  store = c(TRUE, FALSE, TRUE, FALSE),
  price = c(2.5, 8, 10, 7)
)

df
str(df)
```

## Tidy alternative: tibble

```{r}
library(tibble)

df_tbl <- tibble(
  ID    = c(10, 20, 30, 40),
  item  = c("book", "pen", "textbook", "pencil_case"),
  store = c(TRUE, FALSE, TRUE, FALSE),
  price = c(2.5, 8, 10, 7)
)

df_tbl
str(df_tbl)
```

# Slice (index) a data frame

Indexing uses `df[rows, cols]`:
- leaving `rows` blank means “all rows”
- leaving `cols` blank means “all columns”

```{r}
# One cell: row 1, column 2
df

# Rows 1 to 2 (all columns)
df[1:2, ]

# Column 1 (all rows)
df[, 1]
```

Select columns by name:

```{r}
df[, c("ID", "store")]
```

Tip: extracting a single column can be done three ways:

```{r}
df$ID         # convenient interactive use
df[["ID"]]    # safest programmatically
df[, "ID"]    # returns a vector by default
```

# Append a column

A new column must have the same number of rows as the data frame.

```{r}
quantity <- c(10, 35, 40, 5)
df$quantity <- quantity
df
```

If lengths don’t match, R errors:

```{r, error=TRUE}
bad_quantity <- c(10, 35, 40)
df$quantity <- bad_quantity
```

Modern alternative (nice in pipelines):

```{r}
library(dplyr)

df2 <- df |>
  mutate(quantity = c(10, 35, 40, 5))

df2
```

# Subset (filter) rows

## Base R (recommended for clarity)

Use a logical condition inside the row index. This style is explicit and robust.

```{r}
df[df$price > 5, ]
```

## subset()

`subset()` can be convenient for quick exploration, but many workflows prefer bracket indexing for explicitness.

```{r}
subset(df, price > 5)
```

## dplyr::filter() alternative

```{r}
df |>
  filter(price > 5)
```
