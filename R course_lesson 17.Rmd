---
pagetitle: "Lesson 17"
title: "Correlation in R: Pearson & Spearman with Matrix Example"
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  message = FALSE,
  warning = FALSE
)
```

A bivariate relationship describes how two variables change together. **Correlation** is one way to quantify this relationship.

Two widely used correlation measures are:

- **Pearson** correlation: measures *linear* association (parametric).
- **Spearman** correlation: measures *monotonic* association using ranks (non-parametric).

# Pearson correlation

The Pearson correlation coefficient (often denoted \(r\) in samples) measures the strength of a linear relationship between two variables \(x\) and \(y\):

\[
r = \frac{\mathrm{cov}(x,y)}{s_x s_y}
\]

where \(s_x\) and \(s_y\) are the sample standard deviations of \(x\) and \(y\).

The correlation ranges from \(-1\) to \(1\):

- values near 0 indicate little or no linear association,
- values close to 1 or -1 indicate strong positive/negative linear association.

A common test for \(H_0: \rho = 0\) (no correlation in the population) uses:

\[
t = r \sqrt{\frac{n-2}{1-r^2}}
\]

# Spearman rank correlation

Spearman correlation computes Pearson correlation on the **ranks** of the data. It is more robust to outliers and does not require a linear relationship; it is suitable when the relationship is monotonic and/or variables are ordinal.

In R, both Pearson and Spearman correlations can be computed with `cor()` by setting `method`. [web:645]

```{r, eval=FALSE}
cor(x, y, method = c("pearson", "spearman", "kendall"), use = "complete.obs")
```

Important option for missing values:
- `use = "complete.obs"` removes rows with any missing values (listwise deletion),
- `use = "pairwise.complete.obs"` computes each pairwise correlation using available pairs. [web:645]

# Data: British household budget

We will use the BudgetUK dataset (1519 observations, multiple budget shares + demographics).

```{r}
library(dplyr)
library(readr)

path <- "raw_data/british_household.csv"

data_raw <- read_csv(path, show_col_types = FALSE)

data <- data_raw |>
  # Drop an index column if it exists
  select(-any_of(c("X", "x"))) |>
  # Optional: remove extreme income values (threshold chosen for this tutorial)
  filter(income < 500) |>
  mutate(
    log_income = log(income),
    log_totexp = log(totexp),
    children_fac = factor(if_else(children > 0, "Yes", "No"), levels = c("No", "Yes"))
  ) |>
  select(-children, -totexp, -income)

glimpse(data)
```

# Bivariate correlation (Pearson vs Spearman)

```{r}
cor(data$log_income, data$wfood, method = "pearson", use = "pairwise.complete.obs")
cor(data$log_income, data$wfood, method = "spearman", use = "pairwise.complete.obs")
```

# Correlation matrix

A correlation matrix contains pairwise correlations among multiple numeric variables. Since correlations are defined for numeric variables, we first keep numeric columns only.

```{r}
data_num <- data |>
  select(where(is.numeric))

corr_mat <- cor(data_num, method = "pearson", use = "pairwise.complete.obs")
round(corr_mat, 2)
```

Because the matrix is symmetric, it can be convenient to show only one triangle.

```{r}
corr_lower <- round(corr_mat, 2)
corr_lower[upper.tri(corr_lower)] <- NA
corr_lower
```

# Significance levels (p-values)

If you want p-values for each entry in the correlation matrix, you can use `rcorr()` from **Hmisc**.
To avoid masking conflicts with dplyr (`summarise/summarize`), do NOT attach Hmisc with `library(Hmisc)`; call it explicitly with `Hmisc::rcorr()`. [web:656]

```{r}
mat_rcorr <- Hmisc::rcorr(as.matrix(data_num), type = "pearson")

# Correlations
r_values <- round(mat_rcorr[["r"]], 2)

# P-values
p_values <- round(mat_rcorr[["P"]], 3)

r_values
p_values
```

# Visualize the correlation matrix (heat map)

`GGally` extends ggplot2 and provides `ggcorr()` for correlation heatmaps.

```{r}
library(GGally)

GGally::ggcorr(data_num)
```

## Customize the heat map

```{r}
GGally::ggcorr(
  data_num,
  method = c("pairwise", "pearson"),
  nbreaks = 6,
  low = "steelblue",
  mid = "white",
  high = "darkred",
  geom = "circle"
)
```

## Add labels

```{r}
GGally::ggcorr(
  data_num,
  method = c("pairwise", "pearson"),
  nbreaks = 6,
  label = TRUE,
  label_size = 3,
  color = "grey50"
)
```

# ggpairs: multivariate bivariate plots

`GGally::ggpairs()` creates a matrix of plots (distributions on the diagonal, bivariate plots below, and optional correlations above). [web:651]

```{r}
library(ggplot2)

GGally::ggpairs(
  data,
  columns = c("log_totexp", "log_income", "age", "wtrans"),
  title = "Bivariate analysis of expenditure and income (British households)",
  upper = list(continuous = wrap("cor", size = 3)),
  lower = list(continuous = wrap("smooth", alpha = 0.3, linewidth = 0.3)),
  mapping = aes(color = children_fac)
)
```

# Summary

```{r, echo=FALSE}
library(knitr)

dt <- data.frame(
  Library = c("stats", "stats", "Hmisc", "GGally", "GGally"),
  Objective = c("Bivariate correlation", "Correlation matrix", "P-values for correlation matrix", "Correlation heat map", "Pairs plot matrix"),
  Function = c("cor()", "cor()", "rcorr()", "ggcorr()", "ggpairs()"),
  Example = c(
    "cor(x, y, method = 'pearson')",
    "cor(df_num, use = 'pairwise.complete.obs')",
    "Hmisc::rcorr(as.matrix(df_num))",
    "GGally::ggcorr(df_num)",
    "GGally::ggpairs(df, columns = ..., mapping = aes(color = g))"
  )
)

knitr::kable(dt)
```
