---
pagetitle: "Lesson 13"
title: "apply(), lapply(), sapply(), tapply() in R (Modern Syntax + Examples)"
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  message = FALSE,
  warning = FALSE
)
```

# The apply family

The *apply* family helps you iterate over common data structures without writing explicit `for` loops.
Use:
- `apply()` for matrices (or data frames you *treat as matrices*)
- `lapply()` for lists/vectors/data frames (returns a list)
- `sapply()` like `lapply()` but it tries to simplify the result
- `vapply()` like `sapply()` but safer because you pre-specify the output type
- `tapply()` to apply a function by group(s) defined by factor(s)

# apply()

`apply()` works on arrays/matrices. It takes three main arguments:

```{r, eval=FALSE}
apply(X, MARGIN, FUN, ...)
```

- `X`: an array or matrix
- `MARGIN`: where to apply the function
  - `1` = rows
  - `2` = columns
  - `c(1, 2)` = rows and columns
- `FUN`: function to apply (e.g., `sum`, `mean`, custom functions)

## Example: sum columns of a matrix

```{r}
m1 <- matrix(1:30, nrow = 5, ncol = 6)
m1

col_sums_apply <- apply(m1, 2, sum)
col_sums_apply
```

### Tip: prefer dedicated helpers when available
For simple row/column sums, `rowSums()` and `colSums()` are clear and fast:

```{r}
colSums(m1)
rowSums(m1)
```

# lapply()

`lapply()` applies a function to each element of a list/vector (or each column of a data frame) and **always returns a list**.

```{r, eval=FALSE}
lapply(X, FUN, ...)
```

## Example: convert movie titles to lower case

```{r}
movies <- c("SPYDERMAN", "BATMAN", "VERTIGO", "CHINATOWN")

movies_lower_list <- lapply(movies, tolower)
str(movies_lower_list)
```

If you want a character vector instead of a list:

```{r}
movies_lower_vec <- unlist(movies_lower_list, use.names = FALSE)
str(movies_lower_vec)
```

# sapply() (and vapply())

`sapply()` is a “user-friendly” wrapper around `lapply()` that tries to simplify the result into a vector/matrix/array when possible.

```{r, eval=FALSE}
sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
```

`vapply()` is similar but safer because you specify the expected return type/length.

## Example: min/max on the cars dataset

```{r}
dt <- cars

min_l <- lapply(dt, min)
min_s <- sapply(dt, min)
min_v <- vapply(dt, min, numeric(1))  # type-stable

min_l
min_s
min_v
```

```{r}
max_l <- lapply(dt, max)
max_s <- sapply(dt, max)
max_v <- vapply(dt, max, numeric(1))

max_l
max_s
max_v
```

## Using a custom function

```{r}
avg_range <- function(x) {
  (min(x) + max(x)) / 2
}

avg_s <- sapply(dt, avg_range)
avg_v <- vapply(dt, avg_range, numeric(1))

avg_s
avg_v
```

# When sapply() does NOT simplify

If the function returns vectors of **different lengths**, `sapply()` cannot build a matrix and will often fall back to a list (or you can force it with `simplify = FALSE`).

## Example: keep values above the mean (variable length output)

```{r}
above_mean <- function(x) {
  m <- mean(x)
  x[x > m]
}

res_l <- lapply(dt, above_mean)
res_s1 <- sapply(dt, above_mean)                 # may return a list if lengths differ
res_s2 <- sapply(dt, above_mean, simplify = FALSE)

identical(res_l, res_s2)
```

# tapply()

`tapply()` splits a vector into groups defined by a factor (or list of factors) and applies a function to each group.

```{r, eval=FALSE}
tapply(X, INDEX, FUN, ...)
```

- `X`: typically a vector
- `INDEX`: factor (or list of factors) defining groups
- `FUN`: function to apply

## Example: median Sepal.Width by species

```{r}
tapply(iris$Sepal.Width, iris$Species, median)
```

## Modern tidy alternative (optional)

```{r, eval=FALSE}
library(dplyr)

iris |>
  dplyr::group_by(Species) |>
  dplyr::summarise(median_sepal_width = median(Sepal.Width), .groups = "drop")
```
